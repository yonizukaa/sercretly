{"ast":null,"code":"import _defineProperty2 from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport * as React from 'react';\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport View from \"react-native-web/dist/exports/View\";\nimport I18nManager from \"react-native-web/dist/exports/I18nManager\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport TabBarItem from \"./TabBarItem\";\nimport TabBarIndicator from \"./TabBarIndicator\";\n\nvar TabBar = function (_React$Component) {\n  _inherits(TabBar, _React$Component);\n\n  var _super = _createSuper(TabBar);\n\n  function TabBar() {\n    var _this;\n\n    _classCallCheck(this, TabBar);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), \"state\", {\n      layout: {\n        width: 0,\n        height: 0\n      },\n      tabWidths: {}\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"measuredTabWidths\", {});\n\n    _defineProperty(_assertThisInitialized(_this), \"scrollAmount\", new Animated.Value(0));\n\n    _defineProperty(_assertThisInitialized(_this), \"scrollViewRef\", React.createRef());\n\n    _defineProperty(_assertThisInitialized(_this), \"getFlattenedTabWidth\", function (style) {\n      var tabStyle = StyleSheet.flatten(style);\n      return tabStyle ? tabStyle.width : undefined;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"getComputedTabWidth\", function (index, layout, routes, scrollEnabled, tabWidths, flattenedWidth) {\n      if (flattenedWidth === 'auto') {\n        return tabWidths[routes[index].key] || 0;\n      }\n\n      switch (typeof flattenedWidth) {\n        case 'number':\n          return flattenedWidth;\n\n        case 'string':\n          if (flattenedWidth.endsWith('%')) {\n            var width = parseFloat(flattenedWidth);\n\n            if (Number.isFinite(width)) {\n              return layout.width * (width / 100);\n            }\n          }\n\n      }\n\n      if (scrollEnabled) {\n        return layout.width / 5 * 2;\n      }\n\n      return layout.width / routes.length;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"getMaxScrollDistance\", function (tabBarWidth, layoutWidth) {\n      return tabBarWidth - layoutWidth;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"getTabBarWidth\", function (props, state) {\n      var layout = state.layout,\n          tabWidths = state.tabWidths;\n      var scrollEnabled = props.scrollEnabled,\n          tabStyle = props.tabStyle;\n      var routes = props.navigationState.routes;\n      return routes.reduce(function (acc, _, i) {\n        return acc + _this.getComputedTabWidth(i, layout, routes, scrollEnabled, tabWidths, _this.getFlattenedTabWidth(tabStyle));\n      }, 0);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"normalizeScrollValue\", function (props, state, value) {\n      var layout = state.layout;\n\n      var tabBarWidth = _this.getTabBarWidth(props, state);\n\n      var maxDistance = _this.getMaxScrollDistance(tabBarWidth, layout.width);\n\n      var scrollValue = Math.max(Math.min(value, maxDistance), 0);\n\n      if (Platform.OS === 'android' && I18nManager.isRTL) {\n        return maxDistance - scrollValue;\n      }\n\n      return scrollValue;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"getScrollAmount\", function (props, state, index) {\n      var layout = state.layout,\n          tabWidths = state.tabWidths;\n      var scrollEnabled = props.scrollEnabled,\n          tabStyle = props.tabStyle;\n      var routes = props.navigationState.routes;\n      var centerDistance = Array.from({\n        length: index + 1\n      }).reduce(function (total, _, i) {\n        var tabWidth = _this.getComputedTabWidth(i, layout, routes, scrollEnabled, tabWidths, _this.getFlattenedTabWidth(tabStyle));\n\n        return total + (index === i ? tabWidth / 2 : tabWidth);\n      }, 0);\n      var scrollAmount = centerDistance - layout.width / 2;\n      return _this.normalizeScrollValue(props, state, scrollAmount);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"resetScroll\", function (index) {\n      if (_this.props.scrollEnabled) {\n        var _this$scrollViewRef$c;\n\n        (_this$scrollViewRef$c = _this.scrollViewRef.current) === null || _this$scrollViewRef$c === void 0 ? void 0 : _this$scrollViewRef$c.scrollTo({\n          x: _this.getScrollAmount(_this.props, _this.state, index),\n          animated: true\n        });\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleLayout\", function (e) {\n      var _e$nativeEvent$layout = e.nativeEvent.layout,\n          height = _e$nativeEvent$layout.height,\n          width = _e$nativeEvent$layout.width;\n\n      if (_this.state.layout.width === width && _this.state.layout.height === height) {\n        return;\n      }\n\n      _this.setState({\n        layout: {\n          height: height,\n          width: width\n        }\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"getTranslateX\", function (scrollAmount, maxScrollDistance) {\n      return Animated.multiply(Platform.OS === 'android' && I18nManager.isRTL ? Animated.add(maxScrollDistance, Animated.multiply(scrollAmount, -1)) : scrollAmount, I18nManager.isRTL ? 1 : -1);\n    });\n\n    return _this;\n  }\n\n  _createClass(TabBar, [{\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      var navigationState = this.props.navigationState;\n      var _this$state = this.state,\n          layout = _this$state.layout,\n          tabWidths = _this$state.tabWidths;\n\n      if (prevProps.navigationState.routes.length !== navigationState.routes.length || prevProps.navigationState.index !== navigationState.index || prevState.layout.width !== layout.width || prevState.tabWidths !== tabWidths) {\n        if (this.getFlattenedTabWidth(this.props.tabStyle) === 'auto' && !(layout.width && navigationState.routes.every(function (r) {\n          return typeof tabWidths[r.key] === 'number';\n        }))) {\n          return;\n        }\n\n        this.resetScroll(navigationState.index);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _this$props = this.props,\n          position = _this$props.position,\n          navigationState = _this$props.navigationState,\n          jumpTo = _this$props.jumpTo,\n          scrollEnabled = _this$props.scrollEnabled,\n          bounces = _this$props.bounces,\n          getAccessibilityLabel = _this$props.getAccessibilityLabel,\n          getAccessible = _this$props.getAccessible,\n          getLabelText = _this$props.getLabelText,\n          getTestID = _this$props.getTestID,\n          renderBadge = _this$props.renderBadge,\n          renderIcon = _this$props.renderIcon,\n          renderLabel = _this$props.renderLabel,\n          renderTabBarItem = _this$props.renderTabBarItem,\n          activeColor = _this$props.activeColor,\n          inactiveColor = _this$props.inactiveColor,\n          pressColor = _this$props.pressColor,\n          pressOpacity = _this$props.pressOpacity,\n          onTabPress = _this$props.onTabPress,\n          onTabLongPress = _this$props.onTabLongPress,\n          tabStyle = _this$props.tabStyle,\n          labelStyle = _this$props.labelStyle,\n          indicatorStyle = _this$props.indicatorStyle,\n          contentContainerStyle = _this$props.contentContainerStyle,\n          style = _this$props.style,\n          indicatorContainerStyle = _this$props.indicatorContainerStyle;\n      var _this$state2 = this.state,\n          layout = _this$state2.layout,\n          tabWidths = _this$state2.tabWidths;\n      var routes = navigationState.routes;\n      var isWidthDynamic = this.getFlattenedTabWidth(tabStyle) === 'auto';\n      var tabBarWidth = this.getTabBarWidth(this.props, this.state);\n      var tabBarWidthPercent = routes.length * 40 + \"%\";\n      var translateX = this.getTranslateX(this.scrollAmount, this.getMaxScrollDistance(tabBarWidth, layout.width));\n      return React.createElement(Animated.View, {\n        onLayout: this.handleLayout,\n        style: [styles.tabBar, style]\n      }, React.createElement(Animated.View, {\n        pointerEvents: \"none\",\n        style: [styles.indicatorContainer, scrollEnabled ? {\n          transform: [{\n            translateX: translateX\n          }]\n        } : null, tabBarWidth ? {\n          width: tabBarWidth\n        } : scrollEnabled ? {\n          width: tabBarWidthPercent\n        } : null, indicatorContainerStyle]\n      }, this.props.renderIndicator({\n        position: position,\n        layout: layout,\n        navigationState: navigationState,\n        jumpTo: jumpTo,\n        width: isWidthDynamic ? 'auto' : 100 / routes.length + \"%\",\n        style: indicatorStyle,\n        getTabWidth: function getTabWidth(i) {\n          return _this2.getComputedTabWidth(i, layout, routes, scrollEnabled, tabWidths, _this2.getFlattenedTabWidth(tabStyle));\n        }\n      })), React.createElement(View, {\n        style: styles.scroll\n      }, React.createElement(Animated.ScrollView, {\n        horizontal: true,\n        accessibilityRole: \"tablist\",\n        keyboardShouldPersistTaps: \"handled\",\n        scrollEnabled: scrollEnabled,\n        bounces: bounces,\n        alwaysBounceHorizontal: false,\n        scrollsToTop: false,\n        showsHorizontalScrollIndicator: false,\n        automaticallyAdjustContentInsets: false,\n        overScrollMode: \"never\",\n        contentContainerStyle: [styles.tabContent, scrollEnabled ? {\n          width: tabBarWidth || tabBarWidthPercent\n        } : styles.container, contentContainerStyle],\n        scrollEventThrottle: 16,\n        onScroll: Animated.event([{\n          nativeEvent: {\n            contentOffset: {\n              x: this.scrollAmount\n            }\n          }\n        }], {\n          useNativeDriver: true\n        }),\n        ref: this.scrollViewRef\n      }, routes.map(function (route) {\n        var props = {\n          key: route.key,\n          position: position,\n          route: route,\n          navigationState: navigationState,\n          getAccessibilityLabel: getAccessibilityLabel,\n          getAccessible: getAccessible,\n          getLabelText: getLabelText,\n          getTestID: getTestID,\n          renderBadge: renderBadge,\n          renderIcon: renderIcon,\n          renderLabel: renderLabel,\n          activeColor: activeColor,\n          inactiveColor: inactiveColor,\n          pressColor: pressColor,\n          pressOpacity: pressOpacity,\n          onLayout: isWidthDynamic ? function (e) {\n            _this2.measuredTabWidths[route.key] = e.nativeEvent.layout.width;\n\n            if (routes.every(function (r) {\n              return typeof _this2.measuredTabWidths[r.key] === 'number';\n            })) {\n              _this2.setState({\n                tabWidths: _objectSpread({}, _this2.measuredTabWidths)\n              });\n            }\n          } : undefined,\n          onPress: function onPress() {\n            var event = {\n              route: route,\n              defaultPrevented: false,\n              preventDefault: function preventDefault() {\n                event.defaultPrevented = true;\n              }\n            };\n            onTabPress === null || onTabPress === void 0 ? void 0 : onTabPress(event);\n\n            if (event.defaultPrevented) {\n              return;\n            }\n\n            _this2.props.jumpTo(route.key);\n          },\n          onLongPress: function onLongPress() {\n            return onTabLongPress === null || onTabLongPress === void 0 ? void 0 : onTabLongPress({\n              route: route\n            });\n          },\n          labelStyle: labelStyle,\n          style: tabStyle\n        };\n        return renderTabBarItem ? renderTabBarItem(props) : React.createElement(TabBarItem, props);\n      }))));\n    }\n  }]);\n\n  return TabBar;\n}(React.Component);\n\nexport { TabBar as default };\n\n_defineProperty(TabBar, \"defaultProps\", {\n  getLabelText: function getLabelText(_ref) {\n    var route = _ref.route;\n    return route.title;\n  },\n  getAccessible: function getAccessible(_ref2) {\n    var route = _ref2.route;\n    return typeof route.accessible !== 'undefined' ? route.accessible : true;\n  },\n  getAccessibilityLabel: function getAccessibilityLabel(_ref3) {\n    var route = _ref3.route;\n    return typeof route.accessibilityLabel === 'string' ? route.accessibilityLabel : typeof route.title === 'string' ? route.title : undefined;\n  },\n  getTestID: function getTestID(_ref4) {\n    var route = _ref4.route;\n    return route.testID;\n  },\n  renderIndicator: function renderIndicator(props) {\n    return React.createElement(TabBarIndicator, props);\n  }\n});\n\nvar styles = StyleSheet.create({\n  container: {\n    flex: 1\n  },\n  scroll: {\n    overflow: Platform.select({\n      default: 'scroll',\n      web: undefined\n    })\n  },\n  tabBar: {\n    backgroundColor: '#2196f3',\n    elevation: 4,\n    shadowColor: 'black',\n    shadowOpacity: 0.1,\n    shadowRadius: StyleSheet.hairlineWidth,\n    shadowOffset: {\n      height: StyleSheet.hairlineWidth,\n      width: 0\n    },\n    zIndex: 1\n  },\n  tabContent: {\n    flexDirection: 'row',\n    flexWrap: 'nowrap'\n  },\n  indicatorContainer: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0\n  }\n});","map":{"version":3,"sources":["TabBar.tsx"],"names":["TabBar","React","getLabelText","route","getAccessible","getAccessibilityLabel","getTestID","renderIndicator","props","layout","width","height","tabWidths","componentDidUpdate","navigationState","prevProps","prevState","r","Animated","style","tabStyle","StyleSheet","flattenedWidth","routes","parseFloat","Number","tabBarWidth","acc","maxDistance","scrollValue","Math","Platform","I18nManager","centerDistance","length","index","tabWidth","total","scrollAmount","x","animated","e","render","indicatorContainerStyle","isWidthDynamic","tabBarWidthPercent","translateX","styles","scrollEnabled","transform","position","jumpTo","getTabWidth","i","scroll","nativeEvent","contentOffset","useNativeDriver","scrollViewRef","key","renderBadge","renderIcon","renderLabel","activeColor","inactiveColor","pressColor","pressOpacity","onLayout","measuredTabWidths","onPress","event","defaultPrevented","preventDefault","onTabPress","onLongPress","onTabLongPress","labelStyle","renderTabBarItem","container","flex","overflow","default","web","undefined","tabBar","backgroundColor","elevation","shadowColor","shadowOpacity","shadowRadius","shadowOffset","zIndex","tabContent","flexDirection","flexWrap","indicatorContainer","top","left","right","bottom"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  Animated,\n  StyleSheet,\n  View,\n  ScrollView,\n  StyleProp,\n  ViewStyle,\n  TextStyle,\n  LayoutChangeEvent,\n  I18nManager,\n  Platform,\n} from 'react-native';\nimport TabBarItem, { Props as TabBarItemProps } from './TabBarItem';\nimport TabBarIndicator, { Props as IndicatorProps } from './TabBarIndicator';\nimport type {\n  Route,\n  Scene,\n  SceneRendererProps,\n  NavigationState,\n  Layout,\n  Event,\n} from './types';\n\nexport type Props<T extends Route> = SceneRendererProps & {\n  navigationState: NavigationState<T>;\n  scrollEnabled?: boolean;\n  bounces?: boolean;\n  activeColor?: string;\n  inactiveColor?: string;\n  pressColor?: string;\n  pressOpacity?: number;\n  getLabelText: (scene: Scene<T>) => string | undefined;\n  getAccessible: (scene: Scene<T>) => boolean | undefined;\n  getAccessibilityLabel: (scene: Scene<T>) => string | undefined;\n  getTestID: (scene: Scene<T>) => string | undefined;\n  renderLabel?: (\n    scene: Scene<T> & {\n      focused: boolean;\n      color: string;\n    }\n  ) => React.ReactNode;\n  renderIcon?: (\n    scene: Scene<T> & {\n      focused: boolean;\n      color: string;\n    }\n  ) => React.ReactNode;\n  renderBadge?: (scene: Scene<T>) => React.ReactNode;\n  renderIndicator: (props: IndicatorProps<T>) => React.ReactNode;\n  renderTabBarItem?: (\n    props: TabBarItemProps<T> & { key: string }\n  ) => React.ReactElement;\n  onTabPress?: (scene: Scene<T> & Event) => void;\n  onTabLongPress?: (scene: Scene<T>) => void;\n  tabStyle?: StyleProp<ViewStyle>;\n  indicatorStyle?: StyleProp<ViewStyle>;\n  indicatorContainerStyle?: StyleProp<ViewStyle>;\n  labelStyle?: StyleProp<TextStyle>;\n  contentContainerStyle?: StyleProp<ViewStyle>;\n  style?: StyleProp<ViewStyle>;\n};\n\ntype State = {\n  layout: Layout;\n  tabWidths: { [key: string]: number };\n};\n\nexport default class TabBar<T extends Route> extends React.Component<\n  Props<T>,\n  State\n> {\n  static defaultProps = {\n    getLabelText: ({ route }: Scene<Route>) => route.title,\n    getAccessible: ({ route }: Scene<Route>) =>\n      typeof route.accessible !== 'undefined' ? route.accessible : true,\n    getAccessibilityLabel: ({ route }: Scene<Route>) =>\n      typeof route.accessibilityLabel === 'string'\n        ? route.accessibilityLabel\n        : typeof route.title === 'string'\n        ? route.title\n        : undefined,\n    getTestID: ({ route }: Scene<Route>) => route.testID,\n    renderIndicator: (props: IndicatorProps<Route>) => (\n      <TabBarIndicator {...props} />\n    ),\n  };\n\n  state: State = {\n    layout: { width: 0, height: 0 },\n    tabWidths: {},\n  };\n\n  componentDidUpdate(prevProps: Props<T>, prevState: State) {\n    const { navigationState } = this.props;\n    const { layout, tabWidths } = this.state;\n\n    if (\n      prevProps.navigationState.routes.length !==\n        navigationState.routes.length ||\n      prevProps.navigationState.index !== navigationState.index ||\n      prevState.layout.width !== layout.width ||\n      prevState.tabWidths !== tabWidths\n    ) {\n      if (\n        this.getFlattenedTabWidth(this.props.tabStyle) === 'auto' &&\n        !(\n          layout.width &&\n          navigationState.routes.every(\n            (r) => typeof tabWidths[r.key] === 'number'\n          )\n        )\n      ) {\n        // When tab width is dynamic, only adjust the scroll once we have all tab widths and layout\n        return;\n      }\n\n      this.resetScroll(navigationState.index);\n    }\n  }\n\n  // to store the layout.width of each tab\n  // when all onLayout's are fired, this would be set in state\n  private measuredTabWidths: { [key: string]: number } = {};\n\n  private scrollAmount = new Animated.Value(0);\n\n  private scrollViewRef = React.createRef<ScrollView>();\n\n  private getFlattenedTabWidth = (style: StyleProp<ViewStyle>) => {\n    const tabStyle = StyleSheet.flatten(style);\n\n    return tabStyle ? tabStyle.width : undefined;\n  };\n\n  private getComputedTabWidth = (\n    index: number,\n    layout: Layout,\n    routes: Route[],\n    scrollEnabled: boolean | undefined,\n    tabWidths: { [key: string]: number },\n    flattenedWidth: string | number | undefined\n  ) => {\n    if (flattenedWidth === 'auto') {\n      return tabWidths[routes[index].key] || 0;\n    }\n\n    switch (typeof flattenedWidth) {\n      case 'number':\n        return flattenedWidth;\n      case 'string':\n        if (flattenedWidth.endsWith('%')) {\n          const width = parseFloat(flattenedWidth);\n          if (Number.isFinite(width)) {\n            return layout.width * (width / 100);\n          }\n        }\n    }\n\n    if (scrollEnabled) {\n      return (layout.width / 5) * 2;\n    }\n\n    return layout.width / routes.length;\n  };\n\n  private getMaxScrollDistance = (tabBarWidth: number, layoutWidth: number) =>\n    tabBarWidth - layoutWidth;\n\n  private getTabBarWidth = (props: Props<T>, state: State) => {\n    const { layout, tabWidths } = state;\n    const { scrollEnabled, tabStyle } = props;\n    const { routes } = props.navigationState;\n\n    return routes.reduce<number>(\n      (acc, _, i) =>\n        acc +\n        this.getComputedTabWidth(\n          i,\n          layout,\n          routes,\n          scrollEnabled,\n          tabWidths,\n          this.getFlattenedTabWidth(tabStyle)\n        ),\n      0\n    );\n  };\n\n  private normalizeScrollValue = (\n    props: Props<T>,\n    state: State,\n    value: number\n  ) => {\n    const { layout } = state;\n    const tabBarWidth = this.getTabBarWidth(props, state);\n    const maxDistance = this.getMaxScrollDistance(tabBarWidth, layout.width);\n    const scrollValue = Math.max(Math.min(value, maxDistance), 0);\n\n    if (Platform.OS === 'android' && I18nManager.isRTL) {\n      // On Android, scroll value is not applied in reverse in RTL\n      // so we need to manually adjust it to apply correct value\n      return maxDistance - scrollValue;\n    }\n\n    return scrollValue;\n  };\n\n  private getScrollAmount = (props: Props<T>, state: State, index: number) => {\n    const { layout, tabWidths } = state;\n    const { scrollEnabled, tabStyle } = props;\n    const { routes } = props.navigationState;\n\n    const centerDistance = Array.from({ length: index + 1 }).reduce<number>(\n      (total, _, i) => {\n        const tabWidth = this.getComputedTabWidth(\n          i,\n          layout,\n          routes,\n          scrollEnabled,\n          tabWidths,\n          this.getFlattenedTabWidth(tabStyle)\n        );\n\n        // To get the current index centered we adjust scroll amount by width of indexes\n        // 0 through (i - 1) and add half the width of current index i\n        return total + (index === i ? tabWidth / 2 : tabWidth);\n      },\n      0\n    );\n\n    const scrollAmount = centerDistance - layout.width / 2;\n\n    return this.normalizeScrollValue(props, state, scrollAmount);\n  };\n\n  private resetScroll = (index: number) => {\n    if (this.props.scrollEnabled) {\n      this.scrollViewRef.current?.scrollTo({\n        x: this.getScrollAmount(this.props, this.state, index),\n        animated: true,\n      });\n    }\n  };\n\n  private handleLayout = (e: LayoutChangeEvent) => {\n    const { height, width } = e.nativeEvent.layout;\n\n    if (\n      this.state.layout.width === width &&\n      this.state.layout.height === height\n    ) {\n      return;\n    }\n\n    this.setState({\n      layout: {\n        height,\n        width,\n      },\n    });\n  };\n\n  private getTranslateX = (\n    scrollAmount: Animated.Value,\n    maxScrollDistance: number\n  ) =>\n    Animated.multiply(\n      Platform.OS === 'android' && I18nManager.isRTL\n        ? Animated.add(maxScrollDistance, Animated.multiply(scrollAmount, -1))\n        : scrollAmount,\n      I18nManager.isRTL ? 1 : -1\n    );\n\n  render() {\n    const {\n      position,\n      navigationState,\n      jumpTo,\n      scrollEnabled,\n      bounces,\n      getAccessibilityLabel,\n      getAccessible,\n      getLabelText,\n      getTestID,\n      renderBadge,\n      renderIcon,\n      renderLabel,\n      renderTabBarItem,\n      activeColor,\n      inactiveColor,\n      pressColor,\n      pressOpacity,\n      onTabPress,\n      onTabLongPress,\n      tabStyle,\n      labelStyle,\n      indicatorStyle,\n      contentContainerStyle,\n      style,\n      indicatorContainerStyle,\n    } = this.props;\n    const { layout, tabWidths } = this.state;\n    const { routes } = navigationState;\n\n    const isWidthDynamic = this.getFlattenedTabWidth(tabStyle) === 'auto';\n    const tabBarWidth = this.getTabBarWidth(this.props, this.state);\n    const tabBarWidthPercent = `${routes.length * 40}%`;\n    const translateX = this.getTranslateX(\n      this.scrollAmount,\n      this.getMaxScrollDistance(tabBarWidth, layout.width)\n    );\n\n    return (\n      <Animated.View\n        onLayout={this.handleLayout}\n        style={[styles.tabBar, style]}\n      >\n        <Animated.View\n          pointerEvents=\"none\"\n          style={[\n            styles.indicatorContainer,\n            scrollEnabled ? { transform: [{ translateX }] as any } : null,\n            tabBarWidth\n              ? { width: tabBarWidth }\n              : scrollEnabled\n              ? { width: tabBarWidthPercent }\n              : null,\n            indicatorContainerStyle,\n          ]}\n        >\n          {this.props.renderIndicator({\n            position,\n            layout,\n            navigationState,\n            jumpTo,\n            width: isWidthDynamic ? 'auto' : `${100 / routes.length}%`,\n            style: indicatorStyle,\n            getTabWidth: (i: number) =>\n              this.getComputedTabWidth(\n                i,\n                layout,\n                routes,\n                scrollEnabled,\n                tabWidths,\n                this.getFlattenedTabWidth(tabStyle)\n              ),\n          })}\n        </Animated.View>\n        <View style={styles.scroll}>\n          <Animated.ScrollView\n            horizontal\n            accessibilityRole=\"tablist\"\n            keyboardShouldPersistTaps=\"handled\"\n            scrollEnabled={scrollEnabled}\n            bounces={bounces}\n            alwaysBounceHorizontal={false}\n            scrollsToTop={false}\n            showsHorizontalScrollIndicator={false}\n            automaticallyAdjustContentInsets={false}\n            overScrollMode=\"never\"\n            contentContainerStyle={[\n              styles.tabContent,\n              scrollEnabled\n                ? { width: tabBarWidth || tabBarWidthPercent }\n                : styles.container,\n              contentContainerStyle,\n            ]}\n            scrollEventThrottle={16}\n            onScroll={Animated.event(\n              [\n                {\n                  nativeEvent: {\n                    contentOffset: { x: this.scrollAmount },\n                  },\n                },\n              ],\n              { useNativeDriver: true }\n            )}\n            ref={this.scrollViewRef}\n          >\n            {routes.map((route: T) => {\n              const props: TabBarItemProps<T> & { key: string } = {\n                key: route.key,\n                position: position,\n                route: route,\n                navigationState: navigationState,\n                getAccessibilityLabel: getAccessibilityLabel,\n                getAccessible: getAccessible,\n                getLabelText: getLabelText,\n                getTestID: getTestID,\n                renderBadge: renderBadge,\n                renderIcon: renderIcon,\n                renderLabel: renderLabel,\n                activeColor: activeColor,\n                inactiveColor: inactiveColor,\n                pressColor: pressColor,\n                pressOpacity: pressOpacity,\n                onLayout: isWidthDynamic\n                  ? (e) => {\n                      this.measuredTabWidths[route.key] =\n                        e.nativeEvent.layout.width;\n\n                      // When we have measured widths for all of the tabs, we should updates the state\n                      // We avoid doing separate setState for each layout since it triggers multiple renders and slows down app\n                      if (\n                        routes.every(\n                          (r) =>\n                            typeof this.measuredTabWidths[r.key] === 'number'\n                        )\n                      ) {\n                        this.setState({\n                          tabWidths: { ...this.measuredTabWidths },\n                        });\n                      }\n                    }\n                  : undefined,\n                onPress: () => {\n                  const event: Scene<T> & Event = {\n                    route,\n                    defaultPrevented: false,\n                    preventDefault: () => {\n                      event.defaultPrevented = true;\n                    },\n                  };\n\n                  onTabPress?.(event);\n\n                  if (event.defaultPrevented) {\n                    return;\n                  }\n\n                  this.props.jumpTo(route.key);\n                },\n                onLongPress: () => onTabLongPress?.({ route }),\n                labelStyle: labelStyle,\n                style: tabStyle,\n              };\n\n              return renderTabBarItem ? (\n                renderTabBarItem(props)\n              ) : (\n                <TabBarItem {...props} />\n              );\n            })}\n          </Animated.ScrollView>\n        </View>\n      </Animated.View>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  scroll: {\n    overflow: Platform.select({ default: 'scroll', web: undefined }),\n  },\n  tabBar: {\n    backgroundColor: '#2196f3',\n    elevation: 4,\n    shadowColor: 'black',\n    shadowOpacity: 0.1,\n    shadowRadius: StyleSheet.hairlineWidth,\n    shadowOffset: {\n      height: StyleSheet.hairlineWidth,\n      width: 0,\n    },\n    zIndex: 1,\n  },\n  tabContent: {\n    flexDirection: 'row',\n    flexWrap: 'nowrap',\n  },\n  indicatorContainer: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0,\n  },\n});\n"]},"metadata":{},"sourceType":"module"}